<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>MockRequests.js - Documentation</title>
    
    <meta name="description" content="MockRequests will mock both XMLHttpRequest and fetch such that any requested URL will return the specified mock object instead of actually making an async request. URLs not configured will be unaffected and still trigger an async request as normal." />
    
        <meta name="keywords" content="request HTTP requests XMLHttpRequest fetch mock mocks network" />
        <meta name="keyword" content="request HTTP requests XMLHttpRequest fetch mock mocks network" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-mock-requests.html">mock-requests</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-mock-requests-MockRequests.html">MockRequests</a><ul class='methods'><li data-type='method'><a href="module-mock-requests-MockRequests.html#.configure">configure</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.configureDynamicResponses">configureDynamicResponses</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.setMockUrlResponse">setMockUrlResponse</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.setDynamicMockUrlResponse">setDynamicMockUrlResponse</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.getResponse">getResponse</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.deleteMockUrlResponse">deleteMockUrlResponse</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.clearAllMocks">clearAllMocks</a></li><li data-type='method'><a href="module-mock-requests-MockRequests.html#.originalFetch">originalFetch</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">MockRequests.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * MockRequests will mock both XMLHttpRequest and fetch such that
 * any requested URL will return the specified mock object instead
 * of actually making an async request. URLs not configured will
 * be unaffected and still trigger an async request as normal.
 *
 * @module mock-requests
 */

/**
 * @typedef {Object} MockRequestsImport
 * @property {function} configure - {@link module:mock-requests~MockRequests.configure}
 * @property {function} configureDynamicResponses - {@link module:mock-requests~MockRequests.configureDynamicResponses}
 * @property {function} setMockUrlResponse - {@link module:mock-requests~MockRequests.setMockUrlResponse}
 * @property {function} setDynamicMockUrlResponse - {@link module:mock-requests~MockRequests.setDynamicMockUrlResponse}
 * @property {function} getResponse - {@link module:mock-requests~MockRequests.getResponse}
 * @property {function} deleteMockUrlResponse - {@link module:mock-requests~MockRequests.deleteMockUrlResponse}
 * @property {function} clearAllMocks - {@link module:mock-requests~MockRequests.clearAllMocks}
 * @property {function} OriginalXHR - {@link module:mock-requests~MockRequests.OriginalXHR}
 * @property {function} originalFetch - {@link module:mock-requests~MockRequests.originalFetch}
 */

/**
 * @namespace MockRequests
 */

const MockRequests = (/** @returns {MockRequestsImport} */ function MockRequestsFactory() {
    /**
     * @typedef {function} DynamicResponseModFn
     * @param {*} request - Payload passed to the async function
     * @param {*} response - Previous response object to be modified
     * @returns {*} modifiedResponse - Updated response to be saved in the mock response map
     * @memberOf module:mock-requests~MockRequests
     */
    /**
     * @typedef {Object} MockResponseConfig
     * @property {Object} response - Mock response to be returned
     * @property {DynamicResponseModFn} dynamicResponseModFn - Function to dynamically change the response object based on previous request/response
     * @property {number} delay - Optional network mock resolution time
     * @memberOf module:mock-requests~MockRequests
     */

    /**
     * Key (URL string) - Value (mock response) pairs for network mocks
     *
     * @type {Object.&lt;string, MockResponseConfig>}
     */
    let urlResponseMap = {};

    let OriginalXHR;
    let originalFetch;

    /**
     * Initialize the mock with response objects.
     *
     * @param  {Object.&lt;string, Object>} apiUrlResponseConfig - Config object containing URL strings as keys and respective mock response objects as values
     * @param {boolean} [overwritePreviousConfig=true] - If the map from a previous configure call should be maintained (true) or not (false)
     * @memberOf module:mock-requests~MockRequests
     */
    function configure(apiUrlResponseConfig = {}, overwritePreviousConfig = true) {
        const newUrlResponseMap = Object.keys(apiUrlResponseConfig).reduce((mockResponses, key) => {
            mockResponses[key] = {
                response: deepCopyObject(apiUrlResponseConfig[key]),
                dynamicResponseModFn: null,
                delay: null
            };
            return mockResponses;
        }, {});

        if (overwritePreviousConfig) {
            urlResponseMap = newUrlResponseMap;
        } else {
            urlResponseMap = { ...urlResponseMap, ...newUrlResponseMap };
        }
    }

    /**
     * Initialize the mock with response objects and their dynamic update functions
     *
     * @param {Object&lt;string, MockResponseConfig>} dynamicApiUrlResponseConfig
     * @param {boolean} [overwritePreviousConfig=true] - If the map from a previous configure call should be overwritten by this call (true) or not (false)
     * @memberOf module:mock-requests~MockRequests
     */
    function configureDynamicResponses(dynamicApiUrlResponseConfig = {}, overwritePreviousConfig = true) {
        const newUrlResponseMap = Object.keys(dynamicApiUrlResponseConfig).reduce((mockResponses, key) => {
            mockResponses[key] = {
                response: deepCopyObject(dynamicApiUrlResponseConfig[key].response || null),
                dynamicResponseModFn: dynamicApiUrlResponseConfig[key].dynamicResponseModFn,
                delay: dynamicApiUrlResponseConfig[key].delay
            };
            return mockResponses;
        }, {});

        if (overwritePreviousConfig) {
            urlResponseMap = newUrlResponseMap;
        } else {
            urlResponseMap = { ...urlResponseMap, ...newUrlResponseMap };
        }
    }

    /**
     * Mock any network requests to the given URL using the given responseObject
     *
     * @param {string} url - URL to mock
     * @param {Object} response - Mock response object
     * @memberOf module:mock-requests~MockRequests
     */
    function setMockUrlResponse(url, response = null) {
        const mockResponseConfig = urlResponseMap[url] ? urlResponseMap[url] : { response: null, dynamicResponseModFn: null };

        mockResponseConfig.response = deepCopyObject(response);
        urlResponseMap[url] = mockResponseConfig;
    }

    /**
     * Mock any network requests to the given URL using the given responseObject
     * and dynamic response modification function
     *
     * @param {string} url - URL to mock
     * @param {MockResponseConfig} mockResponseConfig - Config object with the fields desired to be configured
     * @param {Object|string|number|boolean} mockResponseConfig.response - Mock response to be resolved
     * @param {function} mockResponseConfig.dynamicResponseModFn - Function to update response object from previous request/response values
     * @param {number} mockResponseConfig.delay - Optional resolution delay time
     * @memberOf module:mock-requests~MockRequests
     */
    function setDynamicMockUrlResponse(url, { response, dynamicResponseModFn, delay } = {}) {
        const mockResponseConfig = urlResponseMap[url] ? urlResponseMap[url] : { response: null, dynamicResponseModFn: null };

        if (response) {
            mockResponseConfig.response = deepCopyObject(response);
        }

        if (dynamicResponseModFn &amp;&amp; typeof dynamicResponseModFn === 'function') {
            mockResponseConfig.dynamicResponseModFn = dynamicResponseModFn;
        } else {
            mockResponseConfig.dynamicResponseModFn = null;
        }

        if (delay) {
            mockResponseConfig.delay = delay;
        }

        urlResponseMap[url] = mockResponseConfig;
    }

    /**
     * Get the mock response object associated with the passed URL
     *
     * @param {string} url
     * @returns {*} - Configured response object
     * @memberOf module:mock-requests~MockRequests
     */
    function getResponse(url) {
        return urlResponseMap[url] ? urlResponseMap[url].response : undefined;
    }

    /**
     * Deletes the URL and respective mock object
     *
     * @param url
     * @returns {boolean}
     * @memberOf module:mock-requests~MockRequests
     */
    function deleteMockUrlResponse(url) {
        return delete urlResponseMap[url];
    }

    /**
     * Deletes all entries in the MockRequests configuration
     *
     * @memberOf module:mock-requests~MockRequests
     */
    function clearAllMocks() {
        urlResponseMap = {};
    }

    /**
     * Deep copies a JS object
     *
     * @param {Object} obj
     * @returns {Object}
     */
    function deepCopyObject(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    /**
     * Gets the `responseText` for XHR or `res.text()` for fetch.
     *
     * @param {*} response
     */
    function castToString(response) {
        return typeof response === typeof {} ? JSON.stringify(response) : `${response}`;
    }

    function urlIsMocked(url) {
        return Object.keys(urlResponseMap).includes(url);
    }

    /**
     * Parse payload content from fetch/XHR such that if it's a stringified object,
     * the object is returned. Otherwise, return the content as-is.
     *
     * @param {*} content
     * @returns {(Object|*)} - Object if the content is a stringified object, otherwise the passed content
     */
    function attemptParseJson(content) {
        let parsedContent;

        try {
            parsedContent = JSON.parse(content);
        } catch (e) {
            parsedContent = content;
        }

        return parsedContent;
    }

    /**
     * Returns the configured mock response. If a dynamic response modification function exists, then modify the
     * response before returning it and save it to the urlRequestMap.
     *
     * @param {string} url
     * @param {*} requestPayload
     * @returns {*} - Configured response after the dynamic modification function has been run (if it exists)
     */
    function getResponseAndDynamicallyUpdate(url, requestPayload) {
        const mockResponseConfig = urlResponseMap[url];

        if (mockResponseConfig.dynamicResponseModFn &amp;&amp; typeof mockResponseConfig.dynamicResponseModFn === 'function') {
            const newResponse = deepCopyObject(
                mockResponseConfig.dynamicResponseModFn(attemptParseJson(requestPayload), mockResponseConfig.response) || null
            );

            mockResponseConfig.response = newResponse;
        }

        return mockResponseConfig.response;
    }

    /**
     * Composes the passed function with a timeout delay if it exists
     *
     * @param {number} delay - Milliseconds delay
     * @param {function} func - Function to wrap
     * @returns {function} - Original function if no delay or same function to be called after a delay
     */
    function withOptionalDelay(delay, func) {
        if (delay) {
            return (...args) => {
                setTimeout(() => {
                    func(...args);
                }, delay);
            };
        }

        return func;
    }

    /**
     * Overwrites the XMLHttpRequest function with a wrapper that
     * mocks the readyState, status, statusText, and various other
     * fields that depend on the status of the request, and applies
     * the mock object response to the `xhr.response` field.
     *
     * The wrapper always marks the request as successful,
     * e.g. status = 200 and statusText = 'OK'
     */
    function overwriteXmlHttpRequestObject() {
        OriginalXHR = XMLHttpRequest;

        XMLHttpRequest = function() {
            const xhr = new OriginalXHR();

            function mockXhrRequest(requestPayload) {
                const mockedResponse = getResponseAndDynamicallyUpdate(xhr.url, requestPayload);
                const mockedValues = {
                    readyState: 4,
                    response: mockedResponse,
                    responseText: castToString(mockedResponse),
                    responseUrl: xhr.url,
                    status: 200,
                    statusText: 'OK',
                    timeout: 0
                };
                const properties = Object.keys(mockedValues).reduce((definedProperties, key) => {
                    definedProperties[key] = {
                        get: () => mockedValues[key],
                        set: val => mockedValues[key] = val
                    };

                    return definedProperties;
                }, {});

                Object.defineProperties(xhr, properties);
            }

            xhr.originalOpen = xhr.open;
            xhr.open = function(method, url, ...args) {
                xhr.url = url;
                xhr.originalOpen(method, url, ...args);
            };

            xhr.originalSend = xhr.send;
            xhr.send = function(requestPayload) {
                if (urlIsMocked(xhr.url)) {
                    mockXhrRequest(requestPayload);
                    const resolveAfterDelay = withOptionalDelay(urlResponseMap[xhr.url].delay, xhr.onreadystatechange);
                    resolveAfterDelay();
                } else {
                    xhr.originalSend(requestPayload);
                }
            };

            return xhr;
        }
    }

    function overwriteFetch() {
        originalFetch = fetch;

        fetch = function(url, options) {
            if (urlIsMocked(url)) {
                const requestPayload = (options &amp;&amp; options.hasOwnProperty('body') &amp;&amp; options.body)
                    ? attemptParseJson(options.body)
                    : undefined;
                const responseBody = getResponseAndDynamicallyUpdate(url, requestPayload);
                const response = {
                    json: () => Promise.resolve(responseBody),
                    text: () => Promise.resolve(castToString(responseBody))
                };

                return new Promise(res => {
                    const resolveAfterDelay = withOptionalDelay(urlResponseMap[url].delay, res);
                    resolveAfterDelay(response);
                });
            } else {
                return originalFetch(url, options);
            }
        }
    }

    if (window.XMLHttpRequest) {
        overwriteXmlHttpRequestObject();
    }

    if (window.fetch) {
        overwriteFetch();
    }

    /**
     * Original XMLHttpRequest class, as defined in the browser
     *
     * @class OriginalXHR
     * @augments XMLHttpRequest
     * @memberOf module:mock-requests~MockRequests
     */
    /**
     * Original fetch function, as defined in the browser
     *
     * @function originalFetch
     * @memberOf module:mock-requests~MockRequests
     */

    return {
        configure,
        configureDynamicResponses,
        setMockUrlResponse,
        setDynamicMockUrlResponse,
        getResponse,
        deleteMockUrlResponse,
        clearAllMocks,
        OriginalXHR,
        originalFetch
    };
})();

export default MockRequests;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Fri Sep 13 2019 20:53:06 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
